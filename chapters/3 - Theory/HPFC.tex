\section{Hybrid position/force control (HPFC)}

The goal of the snake robot is to push against obstacles in a fashion that yields forward propulsion along a path. Consequently, the robot will have to curve itself along the path whilst applying a force to the obstacles considered advantageous. The behavior of the robot has to comprise with the constraints arising from the contact, which further motivates the use of hybrid position/force control (HPFC).

HPFC is not a control method per se, but rather a method for determining when and in which directions force or motion control should be applied. It is desired to control motion along the unconstrained motion directions and force along the constrained motion directions. Different approaches to this problem exist. One is the use of selection matrices, introduced by Raibert and Craig et al. \cite{raibert1981hybrid}. The disadvantage of this approach is that the directions in which force and motion should be controlled has to be recalculated for every step, and is no simple procedure. In another approach, introduced by West and Asada \cite{west1985method}, two projection matrices are used as filters in joint space to automatically select between position- and force controlled vectors. There is however a disadvantage to this method as well, which is that the dynamics of the robot are ignored. A thoroughly studied method called dynamic HPFC, developed by Yoshikawa \cite{yoshikawa1987dynamic}, is therefore presented and adapted to the snake robot.

The theory on traditional HPFC up until the part \textit{Passive joints}, as well as this intro, is a modified part of the earlier project work of the author \cite{AtussaProsjektoppgp}. The rest of the chapter is focused on dynamic HPFC and the advantages and challenges that comes with adapting it to a snake robot model.

\input{chapters/3 - Theory/traditional_hpfc}

\subsection{Dynamic HPFC} \label{subsec:DHPFC}

The solution of West and Asada \cite{west1985method} does not take the manipulator dynamics into account. Nevertheless, in a real system, the dynamics play a significant role in the resulting behavior of the robot. For this reason, Yoshikawa \cite{yoshikawa1987dynamic} designed the dynamic hybrid control method which incorporates the constraints into the manipulator dynamics. More specifically, the solution of \cite{west1985method} filters the commanded joint torques and angles to conform to the constraints. These filters are, as described in \ref{subseq:HPFC}, based on the kinematic Jacobian of the system. The essence of the solution of \cite{yoshikawa1987dynamic} however, is that the robot dynamics and constraint equations are combined before the commanded torques and angles are calculated. 

This section aims at describing the improved method, and the content is based the paper of \cite{yoshikawa1987dynamic}. The symbolic conventions used are for simplicity the same as in the paper. The next section will explain further how the theory and these symbols apply to the snake robot case and the snake robot specific theory presented earlier in this chapter \hl{ref this}.

It is worth noting that the solution of Yoshikawa is designed for a robot manipulator with a static base where the only constraint present is targeted at the manipulator end effector. For this reason, special effort has been put into finding a suitable formulation of the snake robot constraints. Additionally, the difference between the coordinate spaces introduced in the paper are easy to confuse and special attention has been directed at thoroughly defining these spaces for the snake robot so that the following calculations can be both as clear and logical as possible.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/theory/dhpfc_robot.pdf}
    \caption{Model of snake robot and obstacles illustrating joint and obstacle variables}
    \label{fig:dhpfc_robot1}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/theory/dhpfc_robot_2.pdf}
    \caption{Model of snake robot and obstacles illustrating velocity and force directions}
    \label{fig:dhpfc_robot2}
\end{figure}

\subsubsection{Description of constraints}

In order to take the dynamics into account, the constraints are directly included into the dynamic equations of motion of the robot. This is done by expressing the constraints as a set of hypersurfaces that the robot can not physically pass. It should be noted that the focus here is on manipulator end-effector constraints and not general constraints which should be used in the snake robot case. The constraint hypersurfaces are also expressed in the end-effector coordinates. Another important aspect of the paper is that it only addresses bilateral hypersurfaces (and not unilateral surfaces), meaning that the effector is prohibited from leaving the surface in any direction.

It is assumed that a given constraint can be expressed by a set of $m$ hypersurfaces

\begin{equation}\label{eq:hpfc:hypersurface}
    p_i(\mathbf{r}) = 0, \quad i = 1, 2, ..., m,
\end{equation}
\\
where $\mathbf{r}$ is the end effector position in a fixed reference frame. Differentiating (\ref{eq:hpfc:hypersurface}) with respect to time yields

\begin{equation}\label{eq:hpfc:derhypsurf}
    \mathbf{E}_F \mathbf{\dot{r}} = 0,
\end{equation}
\\
where the vectors of $\mathbf{E}_F$ are the unit normal vectors to the hypersurfaces in (\ref{eq:hpfc:hypersurface}).

By comparing the expression (\ref{eq:norm_vel4}) of the constraint on link $i$ found in \ref{seq:constraints} to (\ref{eq:hpfc:derhypsurf}), it is possible to extract the matrix $\mathbf{E}_{F,i}$ and a logical choice of $\mathbf{r}_i$ and $\mathbf{\dot{r}}_i$ presents itself.
Specifically, if one chooses

\begin{equation}
    \mathbf{r}_i =
    \begin{bmatrix}
        x_{c,i} & y_{c,i} & \theta_{c,i}
    \end{bmatrix}^T \in \mathcal{R}^3,
\end{equation}
\\
then $\mathbf{\dot{r}}_i = [\dot{x}_{c,i}, \dot{y}_{c,i}, \dot{\theta}_{c,i}]^T \in \mathcal{R}^3$ and the matrix $\mathbf{E}_{F,i}$ can by comparison be found as

\begin{equation}
    \mathbf{E}_{F,i} =
    \begin{bmatrix}
        -sin(\theta_{c,i}) & cos(\theta_{c,i}) & 0
    \end{bmatrix} \in \mathcal{R}^3.
\end{equation}
\\
The subscript $i$ will now be used as the constraint number, where $n_c$ is the number of constraints/contact points.
The angle of the link at the contact point $\theta_{c,i}$ with respect to the base frame is the same as the angle $\theta$ of the link in contact with respect to the base frame. It can by inspection be seen that $\mathbf{E}_{F,i}$ fulfills the criteria of being of unit size.

These formulations do not supply an explicit expression of the corresponding constraint hypersurface. It is however not a necessity for the further computations. On the other hand it could be valuable to have the expressions for the hypersurfaces for analysis purposes.

The coordinate space $\mathbf{r}$ should be able to aid in expressing all the constraints present on the snake robot. Therefore, it is chosen as 

\begin{equation}
    \mathbf{r} = 
    \begin{bmatrix}
        \mathbf{r}_1^T & \mathbf{r}_2^T & \dots &\mathbf{r}_{n_c}^T
    \end{bmatrix}^T \in \mathcal{R}^{3 n_c}.
\end{equation}
\\
The same goes for $\dot{\mathbf{r}}$. Furthermore, the matrix $\mathbf{E}_{F}$ describing the unit normal vectors to all the hypersurfaces can now be written as

\begin{equation}
    \mathbf{E}_F = 
    \begin{bmatrix}
        \mathbf{E}_{F,1} & \mathbf{0}_{1\times3} & \dots & \mathbf{0}_{1\times3} \\
        \mathbf{0}_{1\times3} & \ddots & & \vdots \\
        \vdots & & \ddots & \mathbf{0}_{1\times3} \\
        \mathbf{0}_{1\times3} & \dots & \mathbf{0}_{1\times3} & \mathbf{E}_{F,n_c} \\
    \end{bmatrix} \in \mathcal{R}^{n_c \times 3 n_c}
\end{equation}
\\

Differentiating (\ref{eq:hpfc:derhypsurf}) further gives

\begin{equation}\label{eq:dhpfc_arf}
    \mathbf{E}_F \mathbf{\ddot{r}} + \mathbf{a}_{r F} = 0, \quad \mathbf{a}_{r F} = \mathbf{\dot{E}}_F\mathbf{\dot{r}}
\end{equation}
\\
For the snake robot case $\mathbf{a}_{r F} \in \mathcal{R}^{n_c}$.

Furthermore, $\mathbf{E}_P$ is chosen so that all the vectors in the relation

\begin{equation}\label{eq:dhpfc_E}
    \mathbf{E} =
    \begin{bmatrix}
    \mathbf{E}_P \\ \mathbf{E}_F
    \end{bmatrix}
\end{equation}
\\
are mutually independent unit vectors. The matrix $\mathbf{E}_F$ represents the coordinate axes normal to the constraint surfaces, and $\mathbf{E}_P$ represents the coordinate axes complementing $\mathbf{E}_F$. Another way to display this is seeing $\mathbf{E}_F$ and $\mathbf{E}_P$ as the axes for force and position constrained directions respectively.

From the equations

\begin{equation}
    \mathbf{E\dot{r}} =
    \begin{bmatrix}
        \mathbf{E}_P \mathbf{\dot{r}}\\
        0
    \end{bmatrix}
    \quad \text{and} \quad
    \mathbf{E\ddot{r}} =
    \begin{bmatrix}
        \mathbf{E}_P \mathbf{\ddot{r}} \\
        -\mathbf{a}_{r F}
    \end{bmatrix}
\end{equation}
\\
it can be seen that the velocity to the constraint surface is zero, which is natural seeing as the end-effector should be physically unable to move through the surface.

For the snake robot, a simple choice of $\mathbf{E}_{P,i}$ with unit vectors complementing $\mathbf{E}_{F,i}$ is by inspection found to be

\begin{equation}\label{eq:dhpfc_EPi}
    \mathbf{E}_{P,i} = 
    \begin{bmatrix}
        cos(\theta_{c,i}) & sin(\theta_{c,i}) & 0 \\
        0 & 0 & 1
    \end{bmatrix} in \mathcal{R}^{2\times 3}.
\end{equation}
\\
Again, $\mathbf{E}_{P,i}$ corresponds to the $i$'th constraint. Combining all $\mathbf{E}_{P,i}$ gives 

\begin{equation}
    \mathbf{E}_P = 
    \begin{bmatrix}
        \mathbf{E}_{P,1} & \mathbf{0}_{2\times3} & \dots & \mathbf{0}_{2\times3} \\
        \mathbf{0}_{2\times3} & \ddots & & \vdots \\
        \vdots & & \ddots & \mathbf{0}_{2\times3} \\
        \mathbf{0}_{2\times3} & \dots & \mathbf{0}_{2\times3} & \mathbf{E}_{P,n_c} \\
    \end{bmatrix} \in \mathcal{R}^{2 n_c \times 3 n_c}
\end{equation}
\\
and $\mathbf{E} \in \mathcal{R}^{3 n_c \times 3 n_c}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Kinematics and dynamics}

In \cite{yoshikawa1987dynamic}, the relation between the joint variable vector $\mathbf{q}$ and the end effector position $\mathbf{r}$ is expressed as

\begin{equation}\label{eq:hpfc:rq}
    \mathbf{r = c(q)}.
\end{equation}
\\
The following equations are generated by differentiating \ref{eq:hpfc:rq}.

\begin{equation}
    \mathbf{\dot{r} = J \dot{q}}, \quad \mathbf{J} = \frac{\partial \mathbf{c(q)}}{\partial \mathbf{q}^T}
\end{equation}

\begin{equation}\label{eq:dhpfc_aq}
    \mathbf{\ddot{r} = J \ddot{q}} + \mathbf{a}_q, \quad \mathbf{a}_q = \mathbf{\dot{J} \dot{q}}   
\end{equation}
\\
For the snake robot case, the matrix $\mathbf{J}$ is the Jacobians of all the contacts/constraints.

\begin{equation}
    \mathbf{J} = 
    \begin{bmatrix}
        \mathbf{J}_1 \\ \mathbf{J}_2 \\ \vdots \\ \mathbf{J}_{n_c}
    \end{bmatrix} \in \mathcal{R}^{3 n_c \times N}
\end{equation}
\\
$N$ is from section \ref{sec:kin} known as the size of $\mathbf{q}$. The Jacobian is also explained in the mentioned section. The Jacobian $\mathbf{J}_i \in \mathcal{R}^{3\times N}$ for a single contact point with respect to the contact point variable vector $\mathbf{r}_i$ is found as 

\begin{equation}
    \mathbf{J}_i =
    \HUGE{
    \begin{bmatrix}
        \frac{\partial x_{c,i}}{\partial q_1} & \dots & \frac{\partial x_{c,i}}{\partial q_N} \\
        \frac{\partial y_{c,i}}{\partial q_1} & \dots & \frac{\partial y_{c,i}}{\partial q_N} \\
        \frac{\partial \theta_{c,i}}{\partial q_1} & \dots & \frac{\partial \theta_{c,i}}{\partial q_N}
    \end{bmatrix}
    }.
\end{equation}
\\
Furthermore, $\mathbf{a}_q \in \mathcal{R}^{n_c}$.


The relationship between the velocity vector $\mathbf{v}$ given in the end effector frame and the velocity vector $\dot{\mathbf{r}}$ in the fixed reference frame is given by the transformation matrix $\mathbf{T}$ in (\ref{eq:hpfc:vTr}).
\begin{equation}\label{eq:hpfc:vTr}
    \mathbf{v = T\dot{r}}
\end{equation}
\\
The interpretation of this velocity vector for the snake robot case is
\begin{equation}
    \mathbf{v}_i = 
    \begin{bmatrix}
        v_{x,i} & v_{y,i}
    \end{bmatrix}^T \in \mathcal{R}^2.
\end{equation}
This is the velocity of the $i$'th contact point given in the coordinate frame of the contact point. This is better explained by the illustration in Figure \ref{}.

The corresponding transformation matrix converting between $\mathbf{r}_i$ and $\mathbf{v}_i$ is

\begin{equation} \label{eq:dhpfc_Ti}
    \mathbf{T}_i =
    \begin{bmatrix}
        cos(\theta_{c,i}) & sin(\theta_{c,i}) & 0 \\
        -sin(\theta_{c,i}) & cos(\theta_{c,i}) & 0
    \end{bmatrix} \in \mathcal{R}^{2 \times 3},
\end{equation}
\\
which is simply a rotation around the local z-axis. Its inverse is given by

\begin{equation}\label{eq:Tinv}
    \mathbf{T}^{-1}_i =
    \begin{bmatrix}
        cos(\theta_{c,i}) & -sin(\theta_{c,i}) \\
        sin(\theta_{c,i}) & cos(\theta_{c,i}) \\
        0 & 0
    \end{bmatrix} \in \mathcal{R}^{3 \times 2}.
\end{equation}
\\
Combining all the transformation matrices yields

\begin{equation}
    \mathbf{T} =
    \begin{bmatrix}
        \mathbf{T}_1 & \mathbf{0}_{2\times3} & \dots & \mathbf{0}_{2\times3} \\
        \mathbf{0}_{2\times3} & \ddots & & \vdots \\
        \vdots & & \ddots & \mathbf{0}_{2\times3} \\
        \mathbf{0}_{2\times3} & \dots & \mathbf{0}_{2\times3} & \mathbf{T}_{n_c} \\
    \end{bmatrix} \in \mathcal{R}^{2 n_c \times 3 n_c}
\end{equation}
\\

From (\ref{eq:hpfc:derhypsurf}) and (\ref{eq:hpfc:vTr}) it follows that

\begin{equation}\label{eq:hpfc:EFTv}
    \mathbf{E}_F \mathbf{T}^{-1} \mathbf{v} = 0.
\end{equation}
\\
Furthermore, it is assumed that no friction works between the constraint surface and the end-effector. Thus, from the principle of virtual work, the force $\mathbf{f}$ exerted on the surface by the effector must follow

\begin{equation}\label{eq:hpfc:vf}
    \mathbf{v}^T \mathbf{f} = 0.
\end{equation}
\\
An interpretation is, like mentioned above, that the force and velocity directions complement each other. From (\ref{eq:hpfc:EFTv}) and (\ref{eq:hpfc:vf}) it follows that

\begin{equation}
    \mathbf{f} = \hat{\mathbf{E}}_F^T \mathbf{f}_F, \quad \hat{\mathbf{E}}_F^T = \mathbf{E}_F \mathbf{T}^{-1},
\end{equation}
\\
where $\mathbf{f}_F$ is an unknown vector representing the force $\mathbf{f}$ in terms of the unit force vectors.

Calculating the force $\mathbf{f}_i$ for a given contact point gives

\begin{equation}
    \begin{split}
        \mathbf{f}_i &= \hat{\mathbf{E}}_{F,i}^T \mathbf{f}_{F,i} = \mathbf{E}_{F,i} \mathbf{T}_i^{-1} \mathbf{f}_{F,i}\\
        &=
        \begin{bmatrix}
            -sin(\theta_{c,i}) & cos(\theta_{c,i}) & 0
        \end{bmatrix}
        \begin{bmatrix}
            cos(\theta_{c,i}) & -sin(\theta_{c,i}) \\
            sin(\theta_{c,i}) & cos(\theta_{c,i}) \\
            0 & 0
        \end{bmatrix}
        \mathbf{f}_{F,i}\\
        &=
        \begin{bmatrix}
            0 \\ 1
        \end{bmatrix}
        \mathbf{f}_{F,i}
    \end{split}
\end{equation}
\\
This result corresponds with the intuition gained from studying figure \ref{}. \hl{Write some more about this result.}

The corresponding torque is found by

\begin{equation}
    \boldsymbol{\tau}_F = (\mathbf{TJ})^T \mathbf{f} = \mathbf{J}^T \mathbf{E}_F^T \mathbf{f}_F.
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Calculation of the joint driving force}

The total torque $\boldsymbol{\tau}$ applied to the robot will be the difference between the motor torque $\boldsymbol{\tau}_c$ and the constraint torque $\boldsymbol{\tau}_F$.

\begin{equation}\label{eq:tau_dhpfc1}
    \boldsymbol{\tau} = \boldsymbol{\tau}_c - \boldsymbol{\tau}_F
\end{equation}
\\

Combining the torque in (\ref{eq:tau_dhpfc1}) with the equations of motion given in (\ref{eq:eom}) gives

\begin{equation}\label{eq:dhpfc_stuff1}
    \mathbf{M(q) \ddot{q}} + \mathbf{J}^T \mathbf{E}^T_F \mathbf{f}_F = \boldsymbol{\tau}_c - \mathbf{C(q, \dot{q})}
\end{equation}
\\
and
\begin{equation}\label{eq:dhpfc_stuff2}
    \mathbf{E}_F \mathbf{J\ddot{q}} = - \mathbf{E}_F \mathbf{a}_q - \mathbf{a}_{rF}.
\end{equation}
\\
Lastly, it can be shown that combining (\ref{eq:dhpfc_stuff1}) and (\ref{eq:dhpfc_stuff2}) yields the expressions

\begin{equation}
    \mathbf{\ddot{q}} = \mathbf{M}^{-1}(\mathbf{b}_1 + (\mathbf{E}_F \mathbf{J})^T \mathbf{K} (\mathbf{b}_2 - \mathbf{E}_F \mathbf{J} \mathbf{M}^{-1} \mathbf{b}_1)),
\end{equation}

\begin{equation}
    \mathbf{f}_F = -\mathbf{K} (\mathbf{b}_2 - \mathbf{E}_F \mathbf{J} \mathbf{M}^{-1} \mathbf{b}_1).
\end{equation}
\\
$\mathbf{K}$, $\mathbf{b}_1$ and $\mathbf{b}_2$ are given by

\begin{equation}
    \begin{split}
        \mathbf{K} &= (\mathbf{E}_F \mathbf{J} \mathbf{M}^{-1} \mathbf{J}^T \mathbf{E}^T_F)^{-1}\\
        \mathbf{b}_1 &= \boldsymbol{\tau}_c - \mathbf{C(q, \dot{q})}\\
        \mathbf{b}_2 &= - \mathbf{E}_F \mathbf{a}_q - \mathbf{a}_{rF}.
    \end{split}
\end{equation}
\\
Eventually, it is possible to calculate the joint control torque. It consists of a component based on the desired movement $\mathbf{\ddot{r}}_d$ and a component based on the desired force $\mathbf{f}_{Fd}$ at applied to the constraint surfaces.

\begin{equation}\label{eq:dhpfc_tau_c}
    \boldsymbol{\tau}_c = \boldsymbol{\tau}_P + \boldsymbol{\tau}_F
\end{equation}
\\
The torque $\boldsymbol{\tau}_P$ is found by solving the equations of motion given in (\ref{eq:eom}) based on the desired values of the joint accelerations.

\begin{equation}
    \boldsymbol{\tau}_P = \mathbf{M(q)} \ddot{\mathbf{q}}_d + \mathbf{C}(\mathbf{q,\dot{q}})
\end{equation}

\begin{equation}
    \boldsymbol{\tau}_F = \mathbf{J}^T \mathbf{E}^T_F \mathbf{f}_{Fd}
\end{equation}

\begin{equation}\label{eq:dhpfc_qddd}
    \ddot{\mathbf{q}}_d = \mathbf{J}^+ (\mathbf{E}^{-1} 
    \begin{bmatrix}
        \mathbf{\ddot{r}}_{EPd} \\
        - \mathbf{a}_{rF}
    \end{bmatrix}
    - \mathbf{a}_q)
\end{equation}
\\
Here the vector $\mathbf{\ddot{r}}_{EPd} = \mathbf{E}_P \mathbf{\ddot{r}}_{d}$. Furthermore, $\mathbf{J}^+$ denotes the pseudo inverse of the Jacobian. According to Yoshikawa \cite{yoshikawa1987dynamic} the position and force can be simultaneously controlled by applying the sum of the joint torque $\boldsymbol{\tau}_P$ for achieving the desired acceleration and the joint torque $\boldsymbol{\tau}_F$ for achieving the desired force as long as the robot is not in a singular state.

Describing the desired acceleration through $\mathbf{\ddot{r}}_d$ might not be the most intuitive task. It is therefore suggested that $\mathbf{E}_P$ is chosen in such a manner that a function $\mathbf{\dot{r}}_P = s(\mathbf{r})$ exists and satisfies

\begin{equation}
    \mathbf{\dot{r}}_P = \mathbf{E}_P \mathbf{\dot{r}}.
\end{equation}
\\
If this holds, then
\begin{equation}
    \mathbf{\ddot{r}}_P = \mathbf{\ddot{r}}_{EP} + \mathbf{a}_{rP}, \quad \mathbf{a}_{rP} = \mathbf{\dot{E}}_P \mathbf{\dot{r}}_P.
\end{equation}
\\
Given that $\mathbf{r}_{P}$ is given by $\mathbf{r}_{Pd}$ and the described dynamics and constraints are correct, the system given by (\ref{eq:dhpfc_tau_c})-(\ref{eq:dhpfc_qddd}) will be able to realize both the desired position and force.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The benefits of dynamic HPFC in snake robot locomotion}

Give a brief overview of the most important strategies for terrestrial snake robot locomotion, and
discuss the prospective properties of HPFC in the context of your findings.

- Controlling both the force and position using compliance control would require us to frequently switch between very very high and very low compliance. Det er vel directional compliance tho

- vi likevel ha en viss compliant behavior i at hvis en hindring beveger seg litt vil slangen følge etter --> men det kan være en assumption at hindringene har statisk posisjon

- Lateral undulation etc is optimal for flat, obstacle-free environments. HPFC is useless in this case

- Allows us to control force and position simultaneously in different directions.

- posisjonsstyring gir stiv oppførsel og krafstyring gir dynamisk oppførsel

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The challenges related to the application of dynamic HPFC}

There are surely several ways of implementing and designing the dynamic HPFC control logic on a snake robot. This section will focus on the challenges related to the application of the suggested design scheme in \ref{subsec:DHPFC}. Special attention is paid to the chosen variable spaces and the consequences of configuration transitions when the snake moves.

\subsubsection{Computational challenges}

Whenever the snake achieves successful forward or backward propulsion it will slide along the obstacles that are by its side. Eventually the contact between a link and an obstacle will be lost. At this point, the obstacle will either be left alone or come in contact with a neighboring link. These two scenarios are illustrated in Figures \ref{fig:obst_slide_seq1} and \ref{fig:obst_slide_seq2} respectively. If the contact is completely lost, it means that one constraint is lost as well and $n_c = n_c - 1$. This will in turn lead to the variable $\mathbf{r}$, describing the position of the contacts, shrinking. Consequently the mapping matrix $\mathbf{E}$ to the allowed force and movement directions will shrink as well. The greatest challenge in this case is changing the dimensions of the relevant variables in real time. One option could however be keeping all variable spaces and instead set the parts of $\mathbf{E}$ corresponding to the lost constraint to zero so that it has no impact on the following solution.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/theory/obst_slide_sequence1.pdf}
    \caption{Snake robot losing contact with obstacle}
    \label{fig:obst_slide_seq1}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/theory/obst_slide_sequence2.pdf}
    \caption{Obstacle changing contact from one link to another}
    \label{fig:obst_slide_seq2}
\end{figure}

If, on the other hand, the snake simply slides in a way that the contact is transferred to an adjoining link, the size $n_c$ and dimensions of all variables will remain unchanged. In addition to this, the obstacle will lie on the same side of the snake as it already was, which enables the direction of the desired force application to the obstacle to stay the same as well. Thus, the constraint will generally be on the same form. The only thing that has to change is the description of the position variables in $\mathbf{r}$ belonging to the new contact point. Again, the change is most probably slim since the two first variables $(x_c, y_c)$ describe the position of the contact point and the obstacle is assumed to be static (meaning its position will not change). Furthermore, the adjoining link adopting the contact is probable to have a similar angle $\theta_c = \theta$ relative to the base frame as the previous link given that the desired path is well designed and defined. This obviously makes the implementation simpler and the control sequence smoother and more predictable.

Even though the magnitude of the mentioned variables do not change drastically, the Jacobian will have to be recalculated since the variables now are described by a new subset of the joint variables. Finding a new expression for the Jacobian matrix and its derivative in real time is not a trivial, nor fast, operation. One option would of course be pre-computing $\mathbf{J}$ and $\dot{\mathbf{J}}$ for every link that could be in contact with an obstacle and only employ the ones that are relevant at the specific time instance. There is however still a challenge related to this case. The generalized joint variables $\mathbf{q}$ contain the distances $k$ from the contact points to the preceding joints. It is important that these distances are not mixed and that they are only used once. In other words, two contact points should not be described by the same $k$. As a consequence of this, the Jacobian for every link would have to be computed with all the possible $k$'s. Logically, this would in turn lead to a large number of pre-computed matrices as the number of links and obstacles grow. In addition to this, the right set of Jacobians would have to be chosen real time while administering that they all use unique $k$'s. This should be done without changing the existing setup more than necessary in order to avoid jumps in the control. It is very much an achievable task, but at the same time an extra challenge.

With a contact moving from one link to another, the corresponding joint variable $k$ describing the position of the contact point will change and the manner in which it is computed will change as well. This is once again an achievable, yet challenging task to perform in real-time. It should also be noted that the value of this $k$ will probably experience a jump. This is because the contact moves from the end of a link to the beginning of a link, or vice versa, and the distance is always measured with respect to the preceding joint of the link in contact. This is illustrated in Figure \ref{fig:obst_slide_seq2}. On the other hand, it is reassuring that the matrices $\mathbf{M(q)}$ and $\mathbf{C(q,\dot{q})}$ are unaltered by the change of a $k$. This is logical since these matrices describe the dynamics of the snake robot alone.

The greatest challenge arises if the number of contact points increase. This means that the dimension of all variables will have to increase correspondingly and the Jacobians have to be either re-computed or re-assembled. It is in this case important to keep in mind the challenge associated with memory allocation in the software being used.

\subsubsection{Differences with the traditional manipulator case}

- Not actuation in all joints / all degrees of freedom (some are uncontrollable)

- Arbitrary number of obstacles and constantly changing requirements (desired force application etc, as opposed to a typical industrial manipulator that simply should polish a surface with a given pressure repeatedly)

- The environment is constantly changing and the contact wont be a point contact in the real world, and the snake robot might encounter all kinds of surfaces and textures (rigid, soft, slippery etc)

\subsubsection{Utilizing the force and position spaces}

Pay special attention to the
roles played by the so-called force and position spaces, and how these can be utilized and further
decomposed to illuminate necessary and sufficient conditions for propulsion.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{chapters/3 - Theory/example_2link}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

